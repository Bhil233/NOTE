# 启动
```
uvicorn main:app --reload
```
main（主程序文件名）
app（实例名）
{--reload}（热加载）

访问FastAPI交互式文档
http://127.0.0.1:8000/does

# 路由

```
@app【FastAPI实例】.get【请求方法】("/")【请求路径】
async def root():
	return {"msg": "hello world"}
```

# 路径参数
**位置**：URL路径的一部分 */book/{id}*
**作用**：指向唯一的、特定的资源
**方法**：GET

原生类型注解添加Path注解
```
@app.get("/author/{author_name}")  
async def get_author_name(author_name: str = Path(..., min_length=2, max_length=10, description="人名，取值范围2-10")):  
    return {"msg": f"这是{author_name}的信息"}
```

# 查询参数
**位置：** URL之后
**作用：** 对资源集合进行过滤、排序、分页等操作
**方法：** GET

```
# 需求： 查询新闻 -> 分页， skip：跳过的记录数， limit：返回的记录数  
@app.get("/news/news_list")  
async def get_news_list(  
        skip: int = Query(0, description="跳过的记录数", lt=100),  
        limit: int = Query(10, description="返回的记录数", lt=100),  
):  
    return {"skip": skip, "limit": limit}
```

# 请求体
**位置**：HTTP请求的消息体（body）中
**作用**：创建、更新资源，携带大量数据，如JSON
**方法**：POST、PUT

```
from pydantic import BaseModel, Field
# 注册功能： 用户名和密码 => strclass User(BaseModel):  
    username: str = Field(  
        default="username",  
        min_length=2,  
        max_length=10,  
        description="用户名，长度2-10"  
    )  
    password: str = Field(  
        min_length=8,  
        max_length=10,  
        description="密码，长度8-10"  
    )  
  
@app.post("/register")  
async def register(user: User):  
    return user
```

# 响应类型设置方式

## 装饰器中指定响应类
场景：固定返回类型（HTML、文本）
```
from fastapi.responses import HTMLResponse
# 接口 响应 HTML 代码  
@app.get("/html", response_class=HTMLResponse)  
async def get_html():  
    return "<h1>Hello World</h1>"
```
## 返回响应对象
场景：文件下载、图片、流式响应
```
@app.get("/file")
async def get_file():
	file_path = ".files/1.jepg"
	return FileResponse(file_path)
```
# 约定响应类型
```
from pydantic import BaseModel
# 需求： 新闻接口 响应数据格式 id,title,contentclass News(BaseModel):  
    id: int  
    title: str  
    content: str  
  
  
@app.get("/news/{news_id}", response_model=News)  
async def get_news(news_id: int):  
    return {  
        "id": news_id,  
        "title": f"这是第 {news_id} 本书",  
        "content": "这是一本好书"  
    }
```
# 异常处理

```
# 需求： 按 news_id 查询新闻 1-6@app.get("/news/{news_id}")  
async def get_news(news_id: int):  
    id_list = [1, 2, 3, 4, 5, 6]  
    if news_id not in id_list:  
        raise HTTPException(status_code=404, detail="您查找的新闻不存在")  
    return {"news_id": news_id}
```

# 中间件

**自下而上执行中间件**
函数顶端使用装饰器```
@app.middleware("http")  
async def middleware(request, call_next):  
    print("中间件1 start")  
    rsp = await call_next(request)  
    print("中间件1 end")  
    return rsp  
  
  
@app.middleware("http")  
async def middleware(request, call_next):  
    print("中间件2 start")  
    rsp = await call_next(request)  
    print("中间件2 end")  
    return rsp```

await 异步

# 依赖注入

中间件控制所有接口
依赖注入可人为控制

```
# 分页参数逻辑公用： 新闻列表和用户列表  
async def common_paramenters(  
        skip: int = Query(0, ge=0),  
        limit: int = Query(10, le=60)  
):  
    return {"skip": skip, "limit": limit}  
  
  
@app.get("/news/{news_list}")  
async def get_news_list(commons=Depends(common_paramenters)):  
    return commons  
  
  
@app.get("/user/{user_list}")  
async def get_user_list(commons=Depends(common_paramenters)):  
    return commons
```